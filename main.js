/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TodosApiPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  defaultSection: "# Observations",
  dailyNotesPath: "Daily Notes",
  excludedDirectories: "Timeless,Archive"
};
var TodosApiPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("Loading Todos REST API plugin");
    await this.loadSettings();
    this.addSettingTab(new TodosApiSettingTab(this.app, this));
    const app = this.app;
    const localRestApiPlugin = app.plugins.plugins["obsidian-local-rest-api"];
    if (!localRestApiPlugin) {
      console.error("Local REST API plugin is not available");
      return;
    }
    this.api = localRestApiPlugin.getPublicApi(this.manifest);
    if (!this.api) {
      console.error("Failed to get Local REST API");
      return;
    }
    this.api.addRoute("/todos/").get(async (request, response) => {
      var _a;
      try {
        const app2 = this.app;
        const dataviewPlugin = app2.plugins.plugins.dataview;
        if (!dataviewPlugin) {
          return response.status(503).json({
            error: "Dataview plugin not found",
            message: "Please install and enable the Dataview plugin"
          });
        }
        const dataviewApi = dataviewPlugin.api;
        if (!dataviewApi) {
          return response.status(503).json({
            error: "Dataview API not available",
            message: "Dataview plugin may not be fully loaded"
          });
        }
        const result = await dataviewApi.query("TASK");
        if (!result.successful) {
          return response.status(500).json({
            error: "Query failed",
            message: result.error
          });
        }
        if (result.value.type !== "task") {
          return response.status(500).json({
            error: "Unexpected result type",
            message: `Expected task result, got ${result.value.type}`
          });
        }
        const tasks = this.flattenTasks(result.value.values);
        const params = new URLSearchParams(request.url.split("?")[1] || "");
        const filterCompleted = params.get("completed");
        const filterPath = params.get("path");
        const filterTag = params.get("tag");
        const filterStatus = params.get("status");
        const excludeDirs = ((_a = params.get("exclude")) == null ? void 0 : _a.split(",").map((d) => d.trim())) || this.settings.excludedDirectories.split(",").map((d) => d.trim());
        let filteredTasks = tasks;
        if (filterCompleted !== null) {
          const showCompleted = filterCompleted === "true";
          filteredTasks = filteredTasks.filter((task) => task.completed === showCompleted);
        }
        if (filterPath) {
          filteredTasks = filteredTasks.filter(
            (task) => task.path.includes(filterPath)
          );
        }
        if (filterTag) {
          filteredTasks = filteredTasks.filter(
            (task) => task.tags && task.tags.some((tag) => tag.includes(filterTag))
          );
        }
        if (filterStatus) {
          filteredTasks = filteredTasks.filter((task) => task.status === filterStatus);
        }
        if (excludeDirs && excludeDirs.length > 0 && excludeDirs[0] !== "") {
          filteredTasks = filteredTasks.filter(
            (task) => !excludeDirs.some((dir) => task.path.startsWith(dir))
          );
        }
        return response.status(200).json({
          count: filteredTasks.length,
          tasks: filteredTasks
        });
      } catch (error) {
        console.error("Error fetching todos:", error);
        return response.status(500).json({
          error: "Internal server error",
          message: error.message
        });
      }
    });
    this.api.addRoute("/todos/").post(async (request, response) => {
      try {
        const app2 = this.app;
        const body = request.body;
        const text = body.text;
        const status = body.status || " ";
        const filePath = body.path || this.getCurrentDailyNotePath();
        if (!text) {
          return response.status(400).json({
            error: "Missing required field",
            message: "Text field is required"
          });
        }
        let file = app2.vault.getAbstractFileByPath(filePath);
        if (!file) {
          return response.status(404).json({
            error: "File not found",
            message: `Could not find file: ${filePath}`
          });
        }
        if (!(file instanceof import_obsidian.TFile)) {
          return response.status(400).json({
            error: "Invalid path",
            message: `Path is not a file: ${filePath}`
          });
        }
        const content = await app2.vault.read(file);
        const sectionHeader = this.settings.defaultSection;
        if (!content.includes(sectionHeader)) {
          return response.status(400).json({
            error: "Section not found",
            message: `Could not find "${sectionHeader}" section in the file`
          });
        }
        const taskLine = `	- [${status}] ${text}`;
        const lines = content.split("\n");
        const sectionIndex = lines.findIndex((line) => line.trim() === sectionHeader);
        lines.splice(sectionIndex + 1, 0, taskLine);
        const newContent = lines.join("\n");
        await app2.vault.modify(file, newContent);
        return response.status(201).json({
          message: "Todo added successfully",
          path: filePath,
          text
        });
      } catch (error) {
        console.error("Error adding todo:", error);
        return response.status(500).json({
          error: "Internal server error",
          message: error.message
        });
      }
    });
    this.api.addRoute("/todos/").patch(async (request, response) => {
      try {
        const app2 = this.app;
        const body = request.body;
        const path = body.path;
        const oldText = body.oldText;
        const newText = body.newText;
        const oldStatus = body.oldStatus || " ";
        const newStatus = body.newStatus || oldStatus;
        if (!path || !oldText || !newText) {
          return response.status(400).json({
            error: "Missing required fields",
            message: "path, oldText, and newText are required"
          });
        }
        const file = app2.vault.getAbstractFileByPath(path);
        if (!file) {
          return response.status(404).json({
            error: "File not found",
            message: `Could not find file: ${path}`
          });
        }
        if (!(file instanceof import_obsidian.TFile)) {
          return response.status(400).json({
            error: "Invalid path",
            message: `Path is not a file: ${path}`
          });
        }
        const content = await app2.vault.read(file);
        const oldTaskLine = `	- [${oldStatus}] ${oldText}`;
        if (!content.includes(oldTaskLine)) {
          return response.status(404).json({
            error: "Task not found",
            message: "The specified task could not be found (it may have been modified)"
          });
        }
        const newTaskLine = `	- [${newStatus}] ${newText}`;
        const newContent = content.replace(oldTaskLine, newTaskLine);
        await app2.vault.modify(file, newContent);
        return response.status(200).json({
          message: "Todo updated successfully",
          path,
          oldText,
          newText
        });
      } catch (error) {
        console.error("Error updating todo:", error);
        return response.status(500).json({
          error: "Internal server error",
          message: error.message
        });
      }
    });
    console.log("Todos REST API routes registered at /todos/");
  }
  /**
   * Flatten the Grouping structure returned by Dataview into a simple array of tasks.
   * The Grouping structure can be nested and contains both individual tasks and groups.
   */
  flattenTasks(grouping) {
    const tasks = [];
    if (Array.isArray(grouping)) {
      for (const item of grouping) {
        if (item.rows) {
          tasks.push(...this.flattenTasks(item.rows));
        } else if (item.task) {
          tasks.push(item);
          if (item.children && item.children.length > 0) {
            tasks.push(...this.flattenTasks(item.children));
          }
        }
      }
    }
    return tasks;
  }
  /**
   * Get the current daily note path
   * @returns The path to the current daily note
   */
  getCurrentDailyNotePath() {
    const today = new Date().toISOString().split("T")[0];
    return `${this.settings.dailyNotesPath}/${today}.md`;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onunload() {
    if (this.api) {
      this.api.unregister();
    }
    console.log("Unloading Todos REST API plugin");
  }
};
var TodosApiSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Todos API Settings" });
    new import_obsidian.Setting(containerEl).setName("Default section").setDesc("The section header where new todos will be added").addText((text) => text.setPlaceholder("# Observations").setValue(this.plugin.settings.defaultSection).onChange(async (value) => {
      this.plugin.settings.defaultSection = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Daily notes path").setDesc("The folder path where daily notes are stored").addText((text) => text.setPlaceholder("Daily Notes").setValue(this.plugin.settings.dailyNotesPath).onChange(async (value) => {
      this.plugin.settings.dailyNotesPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Excluded directories").setDesc("Comma-separated list of directories to exclude from todos list").addText((text) => text.setPlaceholder("Timeless,Archive").setValue(this.plugin.settings.excludedDirectories).onChange(async (value) => {
      this.plugin.settings.excludedDirectories = value;
      await this.plugin.saveSettings();
    }));
  }
};
